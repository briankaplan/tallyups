git diff f13bb99..8fffe03 -- incoming_receipts_service.py viewer_server.py incoming.html
diff --git a/incoming.html b/incoming.html
index b0d0abc..54fe515 100644
--- a/incoming.html
+++ b/incoming.html
@@ -900,6 +900,35 @@ tbody tr:nth-child(5) { animation-delay: 0.1s; }
   border: 1px solid rgba(59,130,246,0.3);
 }
 
+/* Business Type Chips */
+.biz-type-chips {
+  display: flex;
+  gap: 6px;
+  flex-wrap: wrap;
+  margin-bottom: 10px;
+}
+.biz-chip {
+  padding: 6px 12px;
+  border-radius: 16px;
+  font-size: 11px;
+  font-weight: 600;
+  cursor: pointer;
+  transition: all 0.15s;
+  border: 1px solid transparent;
+  background: rgba(255,255,255,0.06);
+  color: var(--muted);
+}
+.biz-chip:hover { background: rgba(255,255,255,0.12); }
+.biz-chip.active {
+  border-color: var(--brand);
+  background: rgba(59,130,246,0.15);
+  color: var(--brand);
+}
+.biz-chip[data-biz="Personal"].active { border-color: #6eb5ff; color: #6eb5ff; background: rgba(110,181,255,0.15); }
+.biz-chip[data-biz="Down Home"].active { border-color: #00ff88; color: #00ff88; background: rgba(0,255,136,0.15); }
+.biz-chip[data-biz="Music City Rodeo"].active { border-color: #ffd85e; color: #ffd85e; background: rgba(255,216,94,0.15); }
+.biz-chip[data-biz="EM.co"].active { border-color: #a855f7; color: #a855f7; background: rgba(168,85,247,0.15); }
+
 /* ============================================
    RECEIPT THUMBNAIL IN CARDS
    ============================================ */
@@ -2286,6 +2315,12 @@ function renderMobileCard(receipt) {
           <span class="match-icon">‚ùì</span>
           <span>No matching expense</span>
         </div>
+        <div class="biz-type-chips" data-receipt="${receipt.id}">
+          <div class="biz-chip active" data-biz="Personal" onclick="event.stopPropagation();selectBizType(this)">Personal</div>
+          <div class="biz-chip" data-biz="Down Home" onclick="event.stopPropagation();selectBizType(this)">Down Home</div>
+          <div class="biz-chip" data-biz="Music City Rodeo" onclick="event.stopPropagation();selectBizType(this)">MCR</div>
+          <div class="biz-chip" data-biz="EM.co" onclick="event.stopPropagation();selectBizType(this)">EM.co</div>
+        </div>
       `;
       primaryAction = `
         <button class="inbox-card-btn accept create" onclick="event.stopPropagation();mobileAccept(${receipt.id}, '${escapeHtml(merchant).replace(/'/g, "\\'")}', ${amount}, ${isRefund}, '${receiptDate}', this)">
@@ -2363,10 +2398,24 @@ function formatDateFull(dateStr) {
   }
 }
 
+// Business type chip selection
+function selectBizType(chip) {
+  const container = chip.closest('.biz-type-chips');
+  container.querySelectorAll('.biz-chip').forEach(c => c.classList.remove('active'));
+  chip.classList.add('active');
+}
+
+// Get selected business type for a receipt card
+function getSelectedBizType(card) {
+  const activeChip = card.querySelector('.biz-chip.active');
+  return activeChip ? activeChip.dataset.biz : 'Personal';
+}
+
 // Mobile accept with visual feedback and duplicate detection
 async function mobileAccept(id, merchant, amount, isRefund, receiptDate, btn) {
   const card = btn.closest('.inbox-card');
   const actionsDiv = card.querySelector('.inbox-card-actions');
+  const businessType = getSelectedBizType(card);
 
   // Show loading state
   actionsDiv.innerHTML = `
@@ -2398,11 +2447,11 @@ async function mobileAccept(id, merchant, amount, isRefund, receiptDate, btn) {
 
       // Store pending accept data
       pendingAccept = {
-        id, merchant, amount, isRefund, transDate, card, actionsDiv,
+        id, merchant, amount, isRefund, transDate, card, actionsDiv, businessType,
         duplicateId: dup.id,
         callback: (forceAccept) => {
           if (forceAccept) {
-            doAccept(id, merchant, amount, isRefund, transDate, card, actionsDiv);
+            doAccept(id, merchant, amount, isRefund, transDate, card, actionsDiv, businessType);
           } else {
             renderMobileCards();
           }
@@ -2414,7 +2463,7 @@ async function mobileAccept(id, merchant, amount, isRefund, receiptDate, btn) {
     }
 
     // No duplicates - proceed with accept
-    await doAccept(id, merchant, amount, isRefund, transDate, card, actionsDiv);
+    await doAccept(id, merchant, amount, isRefund, transDate, card, actionsDiv, businessType);
 
   } catch (e) {
     console.error('Accept error:', e);
@@ -2581,7 +2630,7 @@ async function attachToExpense(receiptId, transactionId, btn) {
 }
 
 // Perform the actual accept
-async function doAccept(id, merchant, amount, isRefund, transDate, card, actionsDiv) {
+async function doAccept(id, merchant, amount, isRefund, transDate, card, actionsDiv, businessType = 'Personal') {
   actionsDiv.innerHTML = `
     <div style="display:flex;align-items:center;gap:8px;justify-content:center;padding:12px;color:var(--brand)">
       <span class="spinner"></span> Processing...
@@ -2599,7 +2648,7 @@ async function doAccept(id, merchant, amount, isRefund, transDate, card, actions
         amount: amount || 0,
         is_refund: isRefund,
         date: transDate,
-        business_type: 'Personal'
+        business_type: businessType
       })
     });
 
diff --git a/incoming_receipts_service.py b/incoming_receipts_service.py
index 523fa29..07c198b 100644
--- a/incoming_receipts_service.py
+++ b/incoming_receipts_service.py
@@ -146,13 +146,48 @@ COWORKER_PATTERNS = [
     'hive', 'hive.com', 'keep using',  # Hive project management spam
 ]
 
-# Spam/marketing sender domains to auto-reject
+# Spam/marketing sender domains to auto-reject (expanded list)
 SPAM_SENDER_DOMAINS = [
+    # Email marketing platforms
     'mailchimp.com', 'sendgrid.net', 'constantcontact.com', 'mailgun.org',
-    'marketing.', 'news.', 'updates.', 'info.', 'promo.',
-    'noreply.', 'no-reply.', 'donotreply.',
     'hubspot.com', 'mailerlite.com', 'klaviyo.com', 'brevo.com',
-    'mixmax.com', 'intercom.io', 'drip.com', 'convertkit.com'
+    'mixmax.com', 'intercom.io', 'drip.com', 'convertkit.com',
+    'campaign-archive.com', 'list-manage.com', 'mcsv.net', 'mailjet.com',
+    'sendinblue.com', 'sparkpost.com', 'postmarkapp.com', 'amazonses.com',
+
+    # Generic subdomains
+    'marketing.', 'news.', 'updates.', 'info.', 'promo.',
+    'noreply.', 'no-reply.', 'donotreply.', 'notifications.',
+    'newsletter.', 'announcements.', 'alerts.', 'mailer.',
+
+    # Social/content platforms
+    'linkedin.com', 'facebook.com', 'facebookmail.com', 'twitter.com',
+    'instagram.com', 'tiktok.com', 'youtube.com', 'pinterest.com',
+    'substack.com', 'medium.com', 'ghost.io', 'beehiiv.com',
+    'buttondown.email', 'revue.email',
+
+    # Event/scheduling platforms
+    'calendly.com', 'eventbrite.com', 'meetup.com', 'luma.co',
+    'hopin.com', 'zoom.us', 'webex.com',  # Notifications, not receipts
+
+    # Forms/surveys
+    'typeform.com', 'surveymonkey.com', 'google.forms', 'airtable.com',
+
+    # CRM/Sales
+    'salesforce.com', 'pipedrive.com', 'freshsales.io', 'close.com',
+
+    # Project management notifications
+    'asana.com', 'monday.com', 'trello.com', 'basecamp.com',
+    'jira.atlassian.com', 'clickup.com',
+
+    # Document signing (not receipts)
+    'docusign.net', 'docusign.com', 'hellosign.com', 'pandadoc.com',
+
+    # GitHub notifications
+    'github.com', 'notifications.github.com',
+
+    # Shipping notifications (not receipts, just tracking)
+    'track.aftership.com', 'narvar.com', 'route.com'
 ]
 
 # Artist/contract patterns (EXCLUDE these)
@@ -261,8 +296,15 @@ def calculate_receipt_confidence(subject, from_email, body_snippet, has_attachme
     if any(x in from_email for x in ['kaplan.brian@gmail.com', 'brian@downhome.com', 'brian@musiccityrodeo.com']):
         return 0
 
-    # 3. Generic vague subjects
-    if subject_lower in ['account payment', 'payment', 'notification', 'update', 'message', 'alert']:
+    # 3. Generic vague subjects - reject unless from trusted domain
+    generic_subjects = [
+        'account payment', 'payment', 'notification', 'update', 'message', 'alert',
+        'confirmation', 'your order', 'order update', 'shipping update',
+        'delivery', 'tracking', 'status update', 'thank you', 'thanks'
+    ]
+    is_trusted_domain = any(svc in domain for svc in PERSONAL_SERVICE_DOMAINS)
+    if subject_lower in generic_subjects and not is_trusted_domain:
+        print(f"      ‚úó Rejected: Generic subject '{subject_lower}' from untrusted domain")
         return 0
 
     # 4. B2B Vendor invoices (net terms, statements, quotes)
@@ -567,6 +609,10 @@ def find_matching_transaction(merchant, amount, transaction_date):
     """
     Check if a similar transaction already exists in the database (MySQL)
     Returns: (transaction_id, has_receipt, needs_receipt)
+
+    Date windows:
+    - With transaction date: ¬±7 days
+    - Without transaction date: last 14 days (was 30, too broad)
     """
     if not merchant:
         return None, False, False
@@ -574,20 +620,23 @@ def find_matching_transaction(merchant, amount, transaction_date):
     conn = get_db_connection()
     cursor = conn.cursor()
 
-    # Search for similar transactions within 7 days
+    # Search for similar transactions within tight date window
     if transaction_date:
         try:
             date_obj = datetime.fromisoformat(transaction_date.split('T')[0])
             date_min = (date_obj - timedelta(days=7)).strftime('%Y-%m-%d')
             date_max = (date_obj + timedelta(days=7)).strftime('%Y-%m-%d')
         except:
-            date_min = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
+            # Fallback: last 14 days (reduced from 30)
+            date_min = (datetime.now() - timedelta(days=14)).strftime('%Y-%m-%d')
             date_max = datetime.now().strftime('%Y-%m-%d')
     else:
-        date_min = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
+        # No date provided: last 14 days (reduced from 30)
+        date_min = (datetime.now() - timedelta(days=14)).strftime('%Y-%m-%d')
         date_max = datetime.now().strftime('%Y-%m-%d')
 
     # Search by merchant name similarity (MySQL uses %s placeholders)
+    # Get multiple candidates and score them to find BEST match
     merchant_pattern = f'%{merchant}%'
 
     cursor.execute('''
@@ -596,26 +645,70 @@ def find_matching_transaction(merchant, amount, transaction_date):
         WHERE chase_description LIKE %s
           AND chase_date BETWEEN %s AND %s
         ORDER BY chase_date DESC
-        LIMIT 1
+        LIMIT 10
     ''', (merchant_pattern, date_min, date_max))
 
-    result = cursor.fetchone()
+    results = cursor.fetchall()
     conn.close()
 
-    if result:
-        # DictCursor returns dict, so access by key
+    if not results:
+        return None, False, False
+
+    # Score each candidate and find the best match
+    best_match = None
+    best_score = 0
+
+    merchant_lower = merchant.lower()
+
+    for result in results:
         trans_id = result['id']
+        trans_desc = result['chase_description'] or ''
         trans_amount = result['chase_amount']
         receipt_file = result.get('receipt_file', '')
         has_receipt = receipt_file and str(receipt_file).strip() != ''
 
-        # Check amount match (within 10%)
-        amount_match = False
+        # Skip if already has receipt
+        if has_receipt:
+            continue
+
+        # Calculate match score
+        score = 0
+
+        # Merchant similarity (0-50 points)
+        desc_lower = trans_desc.lower()
+        if merchant_lower in desc_lower or desc_lower in merchant_lower:
+            score += 50  # Exact substring match
+        elif merchant_lower.split()[0] in desc_lower:
+            score += 30  # First word match
+        else:
+            # Fuzzy match using simple ratio
+            common = sum(1 for c in merchant_lower if c in desc_lower)
+            score += min(25, common * 3)
+
+        # Amount match (0-50 points)
         if amount and trans_amount:
-            diff_pct = abs(amount - float(trans_amount)) / float(trans_amount) * 100
-            amount_match = diff_pct < 10
+            try:
+                diff_pct = abs(amount - float(trans_amount)) / float(trans_amount) * 100
+                if diff_pct < 1:
+                    score += 50  # Near exact
+                elif diff_pct < 5:
+                    score += 40  # Within 5%
+                elif diff_pct < 10:
+                    score += 20  # Within 10%
+                # Beyond 10% = no points
+            except:
+                pass
+
+        if score > best_score:
+            best_score = score
+            best_match = {
+                'id': trans_id,
+                'has_receipt': has_receipt,
+                'amount_match': amount and trans_amount and abs(amount - float(trans_amount)) / float(trans_amount) * 100 < 5
+            }
 
-        return trans_id, has_receipt, (not has_receipt and amount_match)
+    if best_match and best_score >= 50:  # Require minimum score of 50
+        return best_match['id'], best_match['has_receipt'], (not best_match['has_receipt'] and best_match['amount_match'])
 
     return None, False, False
 
@@ -883,13 +976,21 @@ def process_receipt_files(service, email_id, attachments, html_body=None, mercha
             local_files.append(output_path)
             print(f"      ‚úì Saved attachment: {output_path}")
 
-    # If no attachments but has HTML body, screenshot it
+    # If no attachments but has HTML body, screenshot it (with validation)
     if not local_files and html_body:
-        print(f"      üì∏ Screenshotting HTML receipt...")
-        output_path = os.path.join(RECEIPTS_DIR, f"{base_filename}.jpg")
-        result = screenshot_html_receipt(html_body, output_path)
-        if result:
-            local_files.append(result)
+        # Validate HTML contains receipt-like content before screenshotting
+        html_lower = html_body.lower()
+        receipt_indicators = ['$', 'total', 'subtotal', 'amount', 'paid', 'charged', 'invoice', 'receipt', 'order #', 'transaction']
+        has_receipt_content = sum(1 for ind in receipt_indicators if ind in html_lower) >= 2
+
+        if has_receipt_content:
+            print(f"      üì∏ Screenshotting HTML receipt...")
+            output_path = os.path.join(RECEIPTS_DIR, f"{base_filename}.jpg")
+            result = screenshot_html_receipt(html_body, output_path)
+            if result:
+                local_files.append(result)
+        else:
+            print(f"      ‚äò Skipping HTML screenshot: No receipt content detected")
 
     # Upload to R2 for cloud storage
     try:
@@ -915,8 +1016,12 @@ def process_receipt_files(service, email_id, attachments, html_body=None, mercha
     return saved_files
 
 
-def is_likely_receipt(subject, from_email, body_snippet, has_attachment, min_confidence=60):
-    """Check if email is likely a receipt based on content"""
+def is_likely_receipt(subject, from_email, body_snippet, has_attachment, min_confidence=80):
+    """Check if email is likely a receipt based on content
+
+    Raised threshold from 60 to 80 to reduce false positives.
+    Only capture emails with strong receipt signals.
+    """
     confidence = calculate_receipt_confidence(subject, from_email, body_snippet, has_attachment)
     return confidence >= min_confidence, confidence
 
@@ -1142,6 +1247,12 @@ def scan_gmail_for_new_receipts(account_email, since_date='2024-09-01'):
                     if description:
                         print(f"      Description: {description}")
 
+                # === AMOUNT VALIDATION ===
+                # Skip receipts without a valid amount - they're likely not real receipts
+                if not amount_ai or amount_ai <= 0:
+                    print(f"      ‚äò Skipping: No valid amount found (not a real receipt)")
+                    continue
+
                 # Check for matching transaction
                 match_id, has_receipt, needs_receipt = find_matching_transaction(
                     merchant_ai, amount_ai, date_str
@@ -1579,3 +1690,184 @@ if __name__ == '__main__':
                 total_found += 1
 
     print(f"\n‚úÖ Found {total_found} new receipts")
+
+
+# =============================================================================
+# INBOX CLEANUP & RE-MATCHING
+# =============================================================================
+
+def cleanup_inbox_and_rematch():
+    """
+    Clean up existing inbox by:
+    1. Re-evaluating items against stricter filters
+    2. Auto-rejecting items that don't pass
+    3. Re-running matching on valid items
+
+    Returns: dict with cleanup statistics
+    """
+    print("\n" + "="*60)
+    print("üßπ INBOX CLEANUP & RE-MATCHING")
+    print("="*60)
+
+    conn = get_db_connection()
+    cursor = conn.cursor()
+
+    # Get all pending inbox items
+    cursor.execute('''
+        SELECT id, subject, from_email, from_domain, body_snippet,
+               has_attachment, amount, merchant, confidence_score, status
+        FROM incoming_receipts
+        WHERE status = 'pending'
+        ORDER BY created_at DESC
+    ''')
+
+    items = cursor.fetchall()
+    print(f"\nüì• Found {len(items)} pending inbox items to evaluate\n")
+
+    stats = {
+        'total': len(items),
+        'rejected_no_amount': 0,
+        'rejected_spam_domain': 0,
+        'rejected_generic_subject': 0,
+        'rejected_low_confidence': 0,
+        'rejected_no_receipt_content': 0,
+        'kept_valid': 0,
+        'matched': 0,
+        'match_improved': 0
+    }
+
+    for item in items:
+        item_id = item['id']
+        subject = item['subject'] or ''
+        from_email = item['from_email'] or ''
+        from_domain = item['from_domain'] or ''
+        body_snippet = item['body_snippet'] or ''
+        has_attachment = item['has_attachment']
+        amount = item['amount']
+        merchant = item['merchant']
+        old_confidence = item['confidence_score'] or 0
+
+        subject_lower = subject.lower()
+        rejection_reason = None
+
+        # === FILTER 1: No valid amount ===
+        if not amount or float(amount) <= 0:
+            rejection_reason = 'no_valid_amount'
+            stats['rejected_no_amount'] += 1
+
+        # === FILTER 2: Spam domain ===
+        if not rejection_reason:
+            for spam_domain in SPAM_SENDER_DOMAINS:
+                if spam_domain in from_domain.lower() or spam_domain in from_email.lower():
+                    rejection_reason = f'spam_domain:{spam_domain}'
+                    stats['rejected_spam_domain'] += 1
+                    break
+
+        # === FILTER 3: Generic subject from untrusted domain ===
+        if not rejection_reason:
+            generic_subjects = [
+                'account payment', 'payment', 'notification', 'update', 'message', 'alert',
+                'confirmation', 'your order', 'order update', 'shipping update',
+                'delivery', 'tracking', 'status update', 'thank you', 'thanks'
+            ]
+            is_trusted = any(svc in from_domain for svc in PERSONAL_SERVICE_DOMAINS)
+            if subject_lower in generic_subjects and not is_trusted:
+                rejection_reason = f'generic_subject_untrusted:{subject_lower}'
+                stats['rejected_generic_subject'] += 1
+
+        # === FILTER 4: Re-calculate confidence ===
+        if not rejection_reason:
+            new_confidence = calculate_receipt_confidence(subject, from_email, body_snippet, has_attachment)
+            if new_confidence < 80:
+                rejection_reason = f'low_confidence:{new_confidence}'
+                stats['rejected_low_confidence'] += 1
+
+        # === REJECT OR KEEP ===
+        if rejection_reason:
+            cursor.execute('''
+                UPDATE incoming_receipts
+                SET status = 'auto_rejected',
+                    rejection_reason = %s,
+                    reviewed_at = NOW()
+                WHERE id = %s
+            ''', (rejection_reason, item_id))
+            print(f"   ‚ùå Rejected #{item_id}: {rejection_reason[:50]}")
+        else:
+            stats['kept_valid'] += 1
+
+            # === RE-RUN MATCHING ===
+            if merchant and amount:
+                # Try to find a better match
+                match_id, has_receipt, needs_receipt = find_matching_transaction(
+                    merchant, float(amount), None
+                )
+
+                if match_id and needs_receipt:
+                    # Update with new match
+                    cursor.execute('''
+                        UPDATE incoming_receipts
+                        SET matched_transaction_id = %s,
+                            match_type = 'needs_receipt'
+                        WHERE id = %s
+                    ''', (match_id, item_id))
+                    stats['matched'] += 1
+                    print(f"   ‚úÖ Kept #{item_id}: {merchant[:30]} ${amount} ‚Üí Matched to TX #{match_id}")
+                else:
+                    print(f"   ‚úì Kept #{item_id}: {merchant[:30]} ${amount} (no match found)")
+            else:
+                print(f"   ‚úì Kept #{item_id}: Valid receipt (no merchant/amount for matching)")
+
+    conn.commit()
+    conn.close()
+
+    # === SUMMARY ===
+    print("\n" + "="*60)
+    print("üìä CLEANUP SUMMARY")
+    print("="*60)
+    print(f"   Total evaluated:        {stats['total']}")
+    print(f"   ‚ùå Rejected (no amount): {stats['rejected_no_amount']}")
+    print(f"   ‚ùå Rejected (spam):      {stats['rejected_spam_domain']}")
+    print(f"   ‚ùå Rejected (generic):   {stats['rejected_generic_subject']}")
+    print(f"   ‚ùå Rejected (low conf):  {stats['rejected_low_confidence']}")
+    total_rejected = (stats['rejected_no_amount'] + stats['rejected_spam_domain'] +
+                      stats['rejected_generic_subject'] + stats['rejected_low_confidence'])
+    print(f"   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
+    print(f"   Total rejected:         {total_rejected}")
+    print(f"   ‚úÖ Kept valid:          {stats['kept_valid']}")
+    print(f"   üìé Matched to TX:       {stats['matched']}")
+    print("="*60 + "\n")
+
+    return stats
+
+
+def get_inbox_stats():
+    """Get current inbox statistics"""
+    conn = get_db_connection()
+    cursor = conn.cursor()
+
+    cursor.execute('''
+        SELECT
+            COUNT(*) as total,
+            SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
+            SUM(CASE WHEN status = 'accepted' THEN 1 ELSE 0 END) as accepted,
+            SUM(CASE WHEN status = 'rejected' THEN 1 ELSE 0 END) as rejected,
+            SUM(CASE WHEN status = 'auto_rejected' THEN 1 ELSE 0 END) as auto_rejected,
+            SUM(CASE WHEN status = 'auto_matched' THEN 1 ELSE 0 END) as auto_matched,
+            SUM(CASE WHEN matched_transaction_id IS NOT NULL THEN 1 ELSE 0 END) as with_match,
+            SUM(CASE WHEN amount IS NULL OR amount = 0 THEN 1 ELSE 0 END) as no_amount
+        FROM incoming_receipts
+    ''')
+
+    result = cursor.fetchone()
+    conn.close()
+
+    return {
+        'total': result['total'] or 0,
+        'pending': result['pending'] or 0,
+        'accepted': result['accepted'] or 0,
+        'rejected': result['rejected'] or 0,
+        'auto_rejected': result['auto_rejected'] or 0,
+        'auto_matched': result['auto_matched'] or 0,
+        'with_match': result['with_match'] or 0,
+        'no_amount': result['no_amount'] or 0
+    }
diff --git a/viewer_server.py b/viewer_server.py
index e4dc4aa..488dae2 100644
--- a/viewer_server.py
+++ b/viewer_server.py
@@ -18151,6 +18151,60 @@ def clean_incoming_false_positives():
         return jsonify({'ok': False, 'error': str(e)}), 500
 
 
+@app.route("/api/incoming/cleanup", methods=["POST"])
+@login_required
+def cleanup_inbox():
+    """
+    Comprehensive inbox cleanup and re-matching.
+
+    Applies stricter filters to existing pending items:
+    - Rejects items without valid amount
+    - Rejects items from spam domains
+    - Rejects generic subjects from untrusted domains
+    - Rejects items with confidence < 80%
+    - Re-runs matching on valid items using best-match scoring
+    """
+    try:
+        from incoming_receipts_service import cleanup_inbox_and_rematch, get_inbox_stats
+
+        print("üßπ Running inbox cleanup and re-matching...")
+
+        # Get stats before
+        before_stats = get_inbox_stats()
+
+        # Run cleanup
+        results = cleanup_inbox_and_rematch()
+
+        # Get stats after
+        after_stats = get_inbox_stats()
+
+        return jsonify({
+            'ok': True,
+            'message': 'Inbox cleanup complete',
+            'results': {
+                'evaluated': results['total'],
+                'rejected': {
+                    'no_amount': results['rejected_no_amount'],
+                    'spam_domain': results['rejected_spam_domain'],
+                    'generic_subject': results['rejected_generic_subject'],
+                    'low_confidence': results['rejected_low_confidence'],
+                    'total': (results['rejected_no_amount'] + results['rejected_spam_domain'] +
+                              results['rejected_generic_subject'] + results['rejected_low_confidence'])
+                },
+                'kept_valid': results['kept_valid'],
+                'matched': results['matched']
+            },
+            'before': before_stats,
+            'after': after_stats
+        })
+
+    except Exception as e:
+        print(f"‚ùå Error during inbox cleanup: {e}")
+        import traceback
+        traceback.print_exc()
+        return jsonify({'ok': False, 'error': str(e)}), 500
+
+
 @app.route("/api/incoming/whitelist", methods=["GET"])
 @login_required
 def get_merchant_whitelist():